'9*8<
AL4B
"AL7
@P2R
&RC4
GT&1
@ !*8
  !$
 `$B
X h'
!&s 
b ||B
2 !<
@ `<
@ d<
@ l<
@ t<
#H!$
`P!<
 (!$
 (!$
D $$
|X`D
@(!'
D $$
@ !'
|XrD
 (!|B
@(!$
@ !$
@(!$
0#&%M
&$M<
;&$M<
&$MDP@
&$MD
@(!<
$cB@pC
!&1B@
@ !0X
  !$
@0!$
  !<
" !$
IH+Q 
X&1 
d +<
&R8<&sX
C(%<
&0%P@
@ !P@
@ !P@
@ !P@
Tr$ 
<4&1
<4&R
 0!<
@0!$
 +0B
!&s^p
@0!'
@(!&&
 !T@
@ !&
(!&$d
 (!<
  !T@
  !$
@ !&%
@(!$
@8!$
@8!<
!&1A
@(!.X
Q !'
X!,'
` !'
 0!$
@(!<
@0!<
xex$
e`&Re
xex$
!8&8
xex$B
@0!<
$Bs(<
  !<
 f$c
 q$c
@ !r
q8&e
b:<$
&d:<'
&s:<
X0!$
&$vd
&$vd
!h$B
be|$ce|TC
 0!'
  !'
$H!T
e|PC
x8$B
`0!$
e|Rw
$Xel
Xel<
$Xe|<
@ !,B
  !,B
` !$W
@ !$
	&se|
(!P@
e|TX
vdT@
8!l$
G!h<
P!l<
@!h$
X!h'
 0!R`
 !&1
@(!<
(!$c
@(!$
  !'
`0!&R
 (!'
 !&%
A|&2
  !$
 !T@
>.&D
  !$
  !&E
  !$
  !$
  !$
  !$
  !&e
  !$
  !$
@ !<
  !$
2}*X
2r,W
` !'
&D$`
&R$`
`(!$
  !|
<4$E
5'&s
 (!<
(!&s
7a&$
@ !&
@0!<
@0!V 
  !<
@ !'
@ !'
@ !'
@ !'
@ !'
@ !'
@ !'
@ !'
@(!$
@ !'
@ !'
`(!&
@ !'
@ !'
@0!&
@ !'
@ !'
@ !'
@ !'
@0!'
 !T@
 !T@
 (!'
`0!T@
@8!&
 0!P@
$B!`
$c(`
 !P@
`(!0
 (!$
&R(`$
D #$
D +T
>x$c
>x$c
>x$c
X +T
10#(
g8*T
s8*T
!$B3
!&5@
$$c3
$$c38
$$c3
$$c:
$$c;
$$c<,
$$c0\
$$B2,
$$B2
$$B3
$$B!P
$$B<d
$$B/
$$B0
$$BC
$$B=D
$$B=P
$$B=\
$$B=8
$$BG
$$BY
$$BL
$$BJ
$$BMP
$$BK
$$BG
$$BIP
$$B,D
$$BGd
$$BGp
$$BB
$$BW
$$BD 
$$B4
 !&s
'@&1
`(!&1
&1:<&
  !$
C:<$
'HT@
'D&D%
'H&R%
X:<$
=&d%
@ !$
 (!T@
` !P@
D &%
@ !&%
@ !<
@(!P@
@(!$
 (!P@
$B'L
@ !'
W'D$
@ !$
I"&s
` !$
` !$B
` !$
` !$
` !<
@(!'
 !0X
 !0X
&0!'
<4&%L`<
<4&%L`
&%L`
`0!$
&%L`
<4&%L`<
<4&%L`
D&%L`<
 !&%L`
 !T@
@ !<
@(!$
$B<@'
Nf&1
F(#$
8(X'
X(\<
(T$B
"(X<
 !,B
@P!$
	 #$
"(!$B
@(!$
@ !<
RD&D
T/0B
T+0B
Tx$X
E8+P
X+U`
E8+P
X+U`
G@+U
hH+U 
p&Xe
$X[$
d #T
e(+P
X+U`
h@+Q
0!P@
 !,X
`(!&
&E%,
 &E%,
@(!,X
  !<
!&1f,
B5d$
X5d'
^2&1
`0!$
"5h<
85hS
X !$
` !'
@ !$
`(!$
8!T@
@ !<
8!T@
(!P@
` !&1
x(!$
@ !'
0!T@
0!P@
0!P@
d *'
0!P@
$E&X
`0!&
`0!&
`0!&
`0!$
`0!T@
0!P@
 !$R
@0!$
H&E$
@(!&1
UB$BI#
UB$BI#<
UB$BI!
UB$BI!<
mC%E
 *&8
C +T
b0*P
 !TX
&E'T
` !$
0!P@
&E'T
@0!*"
 0!$
#(B 
(!P@
  !&
(!P@
 !P@
rS&s
  !$D
 (!$
  !2
 (!$
@ !<
vx&1
8!P@
8!P@
 !$B
s *T
c *T
vx&1
 !$D
w{$C
wu$D
$c+d
 0!P
0!$c+d
xN&R
$c/d$
8!$c/d
 !&F
@0!,x
6 r3
!$cD
l`!<
q(&$
e(!7
D !'
S8%k
Kx!<
%JsT
*h!<	vj%)
	X!<
d !<
l$cQ
np!<
10&$
xX!<
e(!&D
 !4B
 !4B
 %$B
@8!&
>.$D
 !P@
x !'
 (!|D
!pR0
F(!p
D !$
0#&R
` !$
&R8D<
0#61
d $$
(!2(
b !61
(!2(
((!$
e($$
69$B68$
P+Q@
0!%J
`8!%
`h!%
 #'9
@ !/,
/H#%
$H!%
%(#$	
G8!-
$H#$
$H#%
$H#<
$ #$
Q@%J
Q@%J
DP+U@
8!%B
 $$B
`8!'
` !'
%(#'
Hx+U
/X+Q`
%X+Q`
X!P@
X!$B
&s?"
&s7 
&R3d
NP!-N
np!%
hBU	
%0P@
$B9$
$B7p
~"!@~%
E +P
8!$	
Bp+Q
N(+P
N(+P
P!0I
@(!R
D !$	
 0!<
@ !$
Xgx<
@ !$
@ !$
 0!&
8&ef
 &Eg
@ !T@
 6H<
P6L<
P6L<
P6LV
 0!P@
P6H<
86HV
D6H$
86T<
86T'
86T<
  !&%
 !&ef
Xg|<
Cg|&
  !$
(!&$
@6`<
=&D6
  !$
  !<
  !$
@(!T@
&$7p0
 !&%7p
}\&$f
@(!<
<4&$
<4&$
  !T@
@0!'
@(!T@
` !,B
<4~%
 !T@
(!$	
%(F$B
	H#<
 !$B
&12C
2C&1
 !$B
w0%|B
(!$c
I8%%
(!$	
%(F$B
'8FP
~8%<
	H#&
 !$B
8!|B
D !<
D $T
@8!&
(!$B
R(+T
0!|B
@8!&
	6g(
 (!<
(!T@
  !<
 (!'
x +P
<4&E!
<4&E"
<4&E"
&E",
&R",$
=&R",<
<4&E",
&E"<
 '$B
&R"<<
~&R"<<
<4&E"<
D %<
D %<
&e"|
<4&e"|
&s"|<
^(!<
 (!$
8!&1
`(!<
$B2C<
$B2C<
x %4c
@ !&
@ !&
@ !&
@ !&
@ !&
@ !&
@ !&
@8!<
#(&1
  !&
  !&
  !&
  !&
  !&
  !&
  !&
@8!0B
$&s#L&
@8!$
0!$B
`(!<
$swTable_readEntry
tableAccessForeword
dram_normal_patterns
dram_walking_of_1
dram_walking_of_0
dram_addr_rot
dram_com_addr_rot
dram_half_word_access
dram_byte_access
memcpy_test
unaligned_test
cache_flush_adj_addr
cache_flush_adjacent
cache_flush_dispersed
snaf_scan_block_wr_with_ecc_test
cache_flush_adjacent_toggle_word
cache_flush_dispersed_toggle_word
cache_flush_adjacent_toggle_line128
cache_flush_test
add_one_partition
swCore_netifCreate
vlanTable_create
swNic_send
swNic_init
add_to_list
ubi_wl_get_peb
set_default_env
env_import
saveenv
sc_spi_nand_read_blk
sc_spi_nand_read_page
sc_spi_nand_read_page_oob
sc_spi_nand_write_page
do_env_export
do_env_import
rtl8676_halt
ubi_ro_mode
ubi_ro_mode
ubi_io_read
validate_vid_hdr
ubi_io_write
vtbl_check
do_work
ubi_create_volume
do_sync_erase
uif_init
torture_peb
compare_lebs
io_init
ubi_io_sync_erase
ubi_io_is_bad
autoresize
process_lvol
ubi_io_mark_bad
ubi_scan_add_used
ubi_attach_mtd_dev
validate_ec_hdr
ubi_eba_read_leb
ubi_wl_get_peb
ubi_detach_mtd_dev
init_volumes
ubi_io_read_ec_hdr
check_sv
ubi_init
recover_peb
check_scanning_info
validate_vid_hdr
ubi_scan_erase_peb
ubi_read_volume_table
ubi_eba_write_leb
sync_erase
ubi_io_read_vid_hdr
ubi_scan_get_free_peb
ubi_eba_write_leb_st
process_eb
wear_leveling_worker
ubi_eba_copy_leb
erase_worker
ubi_wl_put_peb
ubi_wl_scrub_peb
ubi_eba_init_scan
ubi_wl_init_scan
ubi_remove_vol
ubi_volume_write
(((((
AAAAAA
BBBBBB
! B0c@
2s"RR
$b4C
6S&r
P:3*
@%pF`g
bwrV
tfdGT$D
fWvvF
XDHex
JuZTj7z
\dLE<
~6NU^t.
 n;^
Qkkbal
i]Wb
9a&g
MGiI
wn>Jj
#.zf
+o*7
 n;^
Qkkbal
i]Wb
9a&g
MGiI
wn>Jj
#.zf
+o*7
bootcmd=bootm
bootdelay=1
ethaddr=00:E0:4C:86:70:01
ipaddr=192.168.1.3
serverip=192.168.1.7
netmask=255.255.255.0
upv=tftp 80000000 vm.img;upvmimg ${fileaddr}
		fx1000_init=mw bb000084 00000048
		sgmii_init=mw bb000084 00000044
sw_tryactive=2
			sw_commit=0
			sw_active=0
			sw_version0=0
			sw_version1=0
			set_act0=if itest.s ${sw_active} != 0;then setenv sw_active 0;saveenv;fi
			set_act1=if itest.s ${sw_active} != 1;then setenv sw_active 1;saveenv;fi
			boot_by_commit=if itest.s ${sw_commit} == 0;then run set_act0;run b0;else run set_act1;run b1;fi
			en_wdt=mw b8003268 e7c00000
			boot_by_tryactive=if itest.s ${sw_tryactive} == 0;then setenv sw_tryactive 2;setenv sw_active 0;saveenv;run en_wdt;run b0;else setenv sw_tryactive 2;setenv sw_active 1;saveenv;run en_wdt;run b1;fi
			bootcmd=if itest.s ${sw_tryactive} == 2; then run boot_by_commit;else run boot_by_tryactive;fi
@0123456789ABCDEF
UUUU
#EgvT2
ZZZZ
0123456789abcdef
ZZZZ
EPTGMK
Jt[%s(%d)] Halt
Mac: %02x:%02x:%02x:%02x:%02x:%02x
malloc failed
RTL SwCore
RTL8367B is detected! 
RTL8211E is detected! 
Ext. phy is not found. 
Set GPHY parameters failed
Tx Desc full!
Assertion fail at file %s, function %s, line number %d: (%s).
swNic_poll.c
((int32) txPkthdrRing[USED_TX_RING][currTxPkthdrDescIndex] & DESC_OWNED_BIT) == DESC_RISC_OWNED
 PTP pkt: %d %d
(uint32) rxPkthdrRing[i] & 0x0fffffff
(uint32) txPkthdrRing[i] & 0x0fffffff
(uint32) rxMbufRing & 0x0fffffff
(uint32) pPkthdrList & 0x0fffffff
(uint32) pMbufList & 0x0fffffff
(uint32) pClusterList & 0x0fffffff
Switch core initialization failed!
Switch nic initialization failed!
Creating netif fails:%d
Creating vlan fails:%d
swTable.c
entryContent_P
vlanTable.c
param
STAT_IfInOctets
STAT_Dot3StatsFCSErrors
STAT_Dot3StatsSymbolErrors
STAT_Dot3InPauseFrames
STAT_Dot3ControlInUnknownOpcodes
STAT_EtherStatsFragments
STAT_EtherStatsJabbers
STAT_IfInUcastPkts
STAT_EtherStatsDropEvents
STAT_EtherStatsOctets
STAT_EtherStatsUnderSizePkts
STAT_EtherOversizeStats
STAT_EtherStatsPkts64Octets
STAT_EtherStatsPkts65to127Octets
STAT_EtherStatsPkts128to255Octets
STAT_EtherStatsPkts256to511Octets
STAT_EtherStatsPkts512to1023Octets
STAT_EtherStatsPkts1024to1518Octets
STAT_EtherStatsMulticastPkts
STAT_EtherStatsBroadcastPkts
STAT_IfOutOctets
STAT_Dot3StatsSingleCollisionFrames
STAT_Dot3StatsMultipleCollisionFrames
STAT_Dot3StatsDeferredTransmissions
STAT_Dot3StatsLateCollisions
STAT_EtherStatsCollisions
STAT_Dot3StatsExcessiveCollisions
STAT_Dot3OutPauseFrames
STAT_Dot1dBasePortDelayExceededDiscards
STAT_Dot1dTpPortInDiscards
STAT_IfOutUcastPkts
STAT_IfOutMulticastPkts
STAT_IfOutBroadcastPkts
STAT_OutOampduPkts
STAT_InOampduPkts
STAT_PktgenPkts
STAT_InMldChecksumError
STAT_InIgmpChecksumError
STAT_InMldSpecificQuery
STAT_InMldGeneralQuery
STAT_InIgmpSpecificQuery
STAT_InIgmpGeneralQuery
STAT_InMldLeaves
STAT_InIgmpInterfaceLeaves
STAT_InIgmpJoinsSuccess
STAT_InIgmpJoinsFail
STAT_InMldJoinsSuccess
STAT_InMldJoinsFail
STAT_InReportSuppressionDrop
STAT_InLeaveSuppressionDrop
STAT_OutIgmpReports
STAT_OutIgmpLeaves
STAT_OutIgmpGeneralQuery
STAT_OutIgmpSpecificQuery
STAT_OutMldReports
STAT_OutMldLeaves
STAT_OutMldGeneralQuery
STAT_OutMldSpecificQuery
STAT_InKnownMulticastPkts
STAT_IfInMulticastPkts
STAT_IfInBroadcastPkts
STAT_PORT_CNTR_END
baudrate
loadaddr
bootfile
Net:   
DRAM: 
*** failed ***
Loading %dB env. variables from offset 0x%x
ipaddr
### ERROR ### Please RESET the board ###
bootargs
memsize
0x%08X
initrd_start
0x%X
initrd_size
flash_start
flash_size
ethaddr
eth1addr
Starting kernel ...
WW: TIMER_FREQ_MHZ (%d) is not divisible by TIMER_STEP_PER_US (%d)
WW: Timer divisor overflow
sleep
delay execution for some time
    - delay execution for N seconds (N is _decimal_ !!!)
*** system s/w reset failed ***
ICACHE: %dKB (%d-byte)
DCACHE: %dKB (%d-byte)
ICACHE: %dKB (%d-byte/%d-way/%d-set)
DCACHE: %dKB (%d-byte/%d-way/%d-set)
MIPS 4KEc
MIPS interAptiv
RLX 5281
MIPS 34Kc
RLX 5181
reset_sw
Perform software RESET
mtdparts=%s:
spinand
%s(%s)ro,
%s(%s),
4K@0ro,
%s@%s(%s),
linux
rootfs
Error: Cannot find rootfs partition
 root=31:%d
fl_size
INFO: flash size=%dMB, but %dMB layout is used.
ERROR: flash size=%dMB, %dMB layout unsupported.
INFO: layout for flash size=%dMB is not defined, %dMB layout is used.
ftfp_base
fl_boot_sz
fl_env
fl_env_sz
fl_cfgfs
fl_cfgfs_sz
fl_kernel1
fl_kernel1_sz
fl_rootfs1
fl_rootfs1_sz
fl_kernel2
fl_kernel2_sz
fl_rootfs2
fl_rootfs2_sz
freeAddr
nand0=%s
mtdids
mtdparts
mtdparts0
mtdparts1
tftp 80000000 img.tar && upimgtar ${fileaddr} ${filesize}
erase_cfgfs
spi_nand erase ${fl_cfgfs} ${fl_cfgfs_sz}
spi_nand erase ${fl_env} ${fl_env_sz} && spi_nand erase ${fl_env2} ${fl_env_sz}
tftp ${ftfp_base} encode_uboot.img && crc32 ${fileaddr} ${filesize} && spi_nand erase 0x0 0x100000 && spi_nand write.raw ${fileaddr} 0x0 ${filesize}
upbs
tftp ${ftfp_base} encode_uboot.img && crc32 ${fileaddr} ${filesize} && spi_nand erase 0x0 0x100000 && spi_nand write.raw ${fileaddr} 0x0 ${filesize} && tftp 0x87000000 sc_do_standalone.bin && spi_nand erase 0x80000 0x20000 && spi_nand write 0x87000000 0x80000 ${filesize}
tftp ${ftfp_base} uImage && crc32 ${fileaddr} ${filesize} && spi_nand erase ${fl_kernel1} ${fl_kernel1_sz} && spi_nand write ${fileaddr} ${fl_kernel1} ${filesize}
tftp ${ftfp_base} rootfs && crc32 ${fileaddr} ${filesize} && spi_nand erase ${fl_rootfs1} ${fl_rootfs1_sz} && spi_nand write ${fileaddr} ${fl_rootfs1} ${filesize}
loady 80000000 && cp.b 80000000 81000000 ${filesize} && cmp.b 80000000 81000000 ${filesize} && spi_nand erase 0 ${filesize} && spi_nand write.raw 80000000 0 ${filesize}
upk1
tftp ${ftfp_base} uImage && crc32 ${fileaddr} ${filesize} && spi_nand erase ${fl_kernel2} ${fl_kernel2_sz} && spi_nand write ${fileaddr} ${fl_kernel2} ${filesize}
upr1
tftp ${ftfp_base} rootfs && crc32 ${fileaddr} ${filesize} && spi_nand erase ${fl_rootfs2} ${fl_rootfs2_sz} && spi_nand write ${fileaddr} ${fl_rootfs2} ${filesize}
bootargs_base
console=ttyS0,115200
setenv bootargs ${bootargs_base} ${mtdparts0};spi_nand read ${freeAddr} ${fl_kernel1} ${fl_kernel1_sz};bootm ${freeAddr}
setenv bootargs ${bootargs_base} ${mtdparts1};spi_nand read ${freeAddr} ${fl_kernel2} ${fl_kernel2_sz};bootm ${freeAddr}
config
opt3
opt4
Skip Bad Block %d
SPI-NAND Flash: %X/Mode%d %dx%uMB
SPI-NAND Flash: Create Bad Block Table Error!
 Block Number is More than %d!
Create bbt: 
%4d 
Don't use bad block skip table!
Device:
 SPI-NAND, ID:%x, size:%u MB*%d 
 each chip has       %8d block(s)
 each block has      %8d page(s)
 page size           %8d byte(s)
 erase size          %8d byte(s)
 spare size          %8d byte(s)
     oob size        %8d byte(s)
     others          %8d byte(s)
WW: ecc check failed (ret 0x%x)
EE: go good block error!
EE: column address incorrect!
%03d%%
Ignore to write blank data in %x
EE: erase failed!
%d block(s) erased 
EE: %s %d, offset 0x%x is not block-alignd!
EE: %s %d, ECC check failed at block %x, page %x!
block %d not care ECC!
EE: %s %d, offset 0x%x is not page-alignd!
EE: %s %d, ECC check failed!
EE: %s %d, Action failed!
Blk at 0x%x is bad, skip to next blk for write!
writing at Bi 0x%x
Blk at 0x%x is bad, skip to next blk for read!
reading at Bi 0x%x
offset(0x%x) is Bad, Skip erasing it.
%d good block(s) erased, skiped %d bad blocks, range is (0x%x ~ 0x%x)
 %d ~ %d
%s%d
EE: page size is not 2048 bytes
EE: argument number error
EE: unknown argument[1]
-all
EE: unknown target: %s
EE: block index error
II: erasing blocks
II: marking bad blocks
II: testing blocks
EE: unknown action, %c
II: %d blocks processed, %d blocks error/bad
%d, 
II: marking bad block %x
nand_badblock
test/set block health status
[action] [target]
  suported actions:
    -b: mark the given block(s) as bad
    -g: mark the given block(s) as good
    -a: test and set health status of given block(s)
    -e: like -a, except with ECC info (to be implemented)
  supported targets:
    <block_id>: apply actions to block ID
          -all: apply actions to all blocks except block 0
        -r m n: apply actions to blocks ranging from m ~ n
  examples:
    nand_badblock -a -all (erase all blocks but block 0 and mark bad blocks)
    nand_badblock -g -r 10 15 (erase block 10 ~ 15)
(not set)
%-12s= 0x%08lX
boot_params
memstart
%-12s= 0x%.8llX
flashstart
flashsize
flashoffset
%-12s= %s
ip_addr     = %pI4
baudrate    = %d bps
bdinfo
print Board Info structure
## Starting application at 0x%08lX ...
## Application terminated, rc = 0x%lX
reset
Perform RESET of the CPU
start application at address 'addr'
addr [arg ...]
    - start application at address 'addr'
      passing 'arg' as arguments
## Checking Image at %08lx ...
   Legacy image found
   Bad Magic Number
   Bad Header Checksum
   Verifying Checksum ... 
   Bad Data CRC
Unknown image format!
bootcmd
## Transferring control to RTEMS (at address %08lx) ...
## Transferring control to NetBSD stage-2 loader (at address %08lx) ...
   XIP %s ... 
   Loading %s ... 
   Uncompressing %s ... 
GUNZIP: uncompress, out-of-mem or overwrite error - must RESET board to recover
LZMA: uncompress or overwrite error %d - must RESET board to recover
Unimplemented compression type %d
verify
## Booting kernel from Legacy Image at %08lx ...
Bad Magic Number
Bad Header Checksum
Bad Data CRC
Unsupported Architecture 0x%x
Wrong Image Type for %s command
Wrong Image Format for %s command
ERROR: can't get kernel image!
ERROR: unknown image format type!
Could not find kernel entry point!
Ramdisk image is corrupt or invalid
Trying to execute a command out of order
cmdline subcommand not supported
bdt subcommand not supported
prep subcommand not supported
WARNING: legacy format multi component image overwritten
ERROR: new format image overwritten - must RESET the board to recover
autostart
filesize
ERROR: booting os '%s' (%d) is not supported
Automatic boot of image at addr 0x%08lX ...
iminfo
print header information for application image
addr [addr ...]
    - print header information for application image starting at
      address 'addr' in memory; this includes verification of the
      image contents (magic number, header and payload checksums)
bootd
boot default, i.e., run 'bootcmd'
bootm
boot application image from memory
[addr [arg ...]]
    - boot application image stored in memory
	passing arguments 'arg ...'; when booting a Linux kernel,
	'arg' can be the address of an initrd image
Sub-commands to do part of the bootm sequence.  The sub-commands must be
issued in the order below (it's ok to not issue all sub-commands):
	start [addr [arg ...]]
	loados  - load OS image
	cmdline - OS specific command line processing/setup
	bdt     - OS specific bd_t processing
	prep    - OS specific prep before relocation or go
	go      - start OS
loados
cmdline
prep
List of available devices:
%-8s %08x %c%c%c 
coninfo
print console devices and information
echo
echo args to console
[args..]
    - echo args to console; \c suppresses newline
exit
exit script
alias for 'help'
help
print command description/usage
	- print brief description of all commands
help command ...
	- print detailed usage of 'command'
Unknown operator '%s'
Invalid data width specifier
itest
return true/false on integer compare
[.b, .w, .l, .s] [*]value1 <op> [*]value2
## Total Size      = 0x%08x = %d Bytes
## First Load Addr = 0x%08lX
## Last  Load Addr = 0x%08lX
## Total Size      = 0x%08lX = %ld Bytes
loads_echo
## Ready for S-Record download ...
## S-Record download aborted
## Start Addr      = 0x%08lX
## Switch baudrate to %d bps and press ENTER ...
loady
## Ready for binary (ymodem) download to 0x%08lX at %d bps...
## Ready for binary (kermit) download to 0x%08lX at %d bps...
## Binary (kermit) download aborted
## Switch baudrate to %d bps and press ESC ...
load binary file over serial line (ymodem mode)
[ off ] [ baud ]
    - load binary file over serial line with offset 'off' and baudrate 'baud'
loadb
load binary file over serial line (kermit mode)
loads
load S-Record file over serial line
[ off ]
    - load S-Record file over serial line with offset 'off'
Base Address: 0x%08lx
Tested %d iteration(s) with %lu errors.
Pattern %08lX  Writing...%12s
Reading...
Mem error @ 0x%08X: found %08lX, expected %08lX
byte
halfword
word at 0x%08lx (0x%08lx) != word at 0x%08lx (0x%08lx)
halfword at 0x%08lx (0x%04x) != halfword at 0x%08lx (0x%04x)
byte at 0x%08lx (0x%02x) != byte at 0x%08lx (0x%02x)
Total of %ld %s%s were the same
%08lx:
 %08x
 %04x
 %02x
Zero length ???
CRC32 for %08lx ... %08lx ==> %08lx
mtest
simple RAM read/write test
[start [end [pattern [iterations]]]]
loop
infinite loop on address range
[.b, .w, .l] address number_of_objects
base
print or set address offset
    - print address offset for memory commands
base off
    - set address offset for memory commands to 'off'
crc32
checksum calculation
address count [addr]
    - compute CRC32 checksum [save at addr]
memory compare
[.b, .w, .l] addr1 addr2 count
memory copy
[.b, .w, .l] source target count
memory write (fill)
[.b, .w, .l] address value [count]
memory modify (constant address)
[.b, .w, .l] address
memory modify (auto-incrementing address)
memory display
[.b, .w, .l] address [# of objects]
onenand
invalid partition number %d for device %s%d (%s)
mtddevnum
mtddevname
%s%d,%d
partition
cannot add second partition at offset 0
mtdparts=
Device %s not found!
%s: offset %08x beyond flash size %08x
%s%d: partition (%s) size too big
%s: partitioning exceeds flash size
%s%d: partition (%s) start offsetalignment incorrect
%s%d: partition (%s) size alignment incorrect
%s%d: partition (%s) start offset alignment incorrect
invalid mtd device '%.*s'
partition size too small (%lx)
no closing ) found in partition name
empty partition name
no partitions allowed after a fill-up partition
unexpected character '%c' at the end of partition
out of memory
0x%08lx@0x%08lx
no partitions for device %s%d (%s)
unexpected character '%c' at the end of device
incorrect device type in %s
incorrect device number in %s
no partition number specified
unexpected trailing character '%c'
no such device %s%d
no such partition
mtdids not defined, no default present
mtdids too long (> %d)
mtdparts variable not set, see 'help mtdparts'
mtdparts too long (> %d)
mtdids: incorrect <dev-num>
mtdids: no <mtd-id> identifier
device id %s%d redefined, please correct mtdids variable
could not initialise device list
mtdparts variable doesn't start with 'mtdparts='
device %s%d redefined, please correct mtdparts variable
mtdparts_init: no valid partitions
no partition id specified
partition changed to %s%d,%d
default
delall
device %s%d <%s>, # parts = %d
 #: name		size		offset		mask_flags
%2d: %-20s0x%08x	0x%08x	%d
no partitions defined
active partition: %s%d,%d - (%s) 0x%08x @ 0x%08x
could not get current partition info
defaults:
mtdids  : %s
none
mtdparts: 
no such device %s defined in mtdids variable
too long partition description
%s:%s(%s)%s
generated mtdparts too long, reseting to null
current partition deleted, resetting current to 0
partition %s not found
define flash/nand partitions
    - list partition table
mtdparts delall
    - delete all partitions
mtdparts del part-id
    - delete partition (e.g. part-id = nand0,1)
mtdparts add <mtd-dev> <size>[@<offset>] [<name>] [ro]
    - add partition
mtdparts default
    - reset partition table to defaults
-----
this command uses three environment variables:
'partition' - keeps current partition identifier
partition  := <part-id>
<part-id>  := <dev-id>,part_num
'mtdids' - linux kernel mtd device id <-> u-boot device id mapping
mtdids=<idmap>[,<idmap>,...]
<idmap>    := <dev-id>=<mtd-id>
<dev-id>   := 'nand'|'nor'|'onenand'<dev-num>
<dev-num>  := mtd device number, 0...
<mtd-id>   := unique device tag used by linux kernel to find mtd device (mtd->name)
'mtdparts' - partition list
mtdparts=mtdparts=<mtd-def>[;<mtd-def>...]
<mtd-def>  := <mtd-id>:<part-def>[,<part-def>...]
<mtd-id>   := unique device tag used by linux kernel to find mtd device (mtd->name)
<part-def> := <size>[@<offset>][<name>][<ro-flag>]
<size>     := standard linux memsize OR '-' to denote all remaining space
<offset>   := partition start offset within the device
<name>     := '(' NAME ')'
<ro-flag>  := when set to 'ro' makes partition read-only (not used, passed to kernel)
chpart
change active partition
part-id
    - change active partition (e.g. part-id = nand0,1)
gatewayip
netmask
hostname
rootpath
serverip
dnsip
domain
tftpboot
boot image via network using TFTP protocol
[loadAddress] [[hostIPaddr:]bootfilename]
bootp
boot image via network using BOOTP/TFTP protocol
Not implemented yet
%s=%s
Saving Environment to %s...
## Warning: defaulting to text format
## Info: input data size = %zu = 0x%zX
## Error: bad CRC, import failed
ERROR: Environment import failed: errno = %d
at %s:%d/%s()
cmd_nvedit.c
## %s: only one of "-b", "-c" or "-t" allowed
## Warning: Input data exceeds %d bytes - truncated
## Resetting to default environment
Environment size: %d/%ld bytes
## Error: "%s" not defined
## Error: illegal character '=' in variable name"%s"
stdin
stdout
stderr
Can't delete "%s"
## Baudrate %d bps not supported
## Can't malloc %d bytes
## Error inserting "%s" variable, errno=%d
## Switch baudrate to %d bps andpress ENTER ...
setenv
ERROR: Cannot export environment: errno = %d
at %s:%d/%s()
env_buf [%d bytes] too small for value of "%s"
edit: 
run commands in an environment variable
var [...]
    - run the commands in the environment variable(s) 'var'
set environment variables
name value ...
    - set environment variable 'name' to 'value ...'
setenv name
    - delete environment variable 'name'
printenv
print environment variables
    - print values of all environment variables
printenv name ...
    - print value of environment variable 'name'
editenv
edit environment variable
name
    - edit environment variable 'name'
environment handling commands
default -f - reset default environment
env edit name - edit environment variable
env export [-t | -b | -c] [-s size] addr [var ...] - export environment
env import [-d] [-t | -b | -c] addr [size] - import environment
env print [name ...] - print environment
env run var [...] - run commands in an environment variable
env save - save environment
env set [-f] name [arg ...]
delete
edit
export
import
print
save
saveenv
save environment variables to persistent storage
Bad magic number
Bad header crc
Bad data crc
Bad image type
Empty Script
Wrong image format for "source" command
## Executing script at %08lx
source
run script from memory
[addr]
	- run script starting at addr
	- A valid image header must be present
info
read
write
EE: incorrect addr.
.raw
done
erase
Not Supported!
spi_nand_sc
SPI-NAND sub-system SC Mod
info - show available NAND devices
spi_nand_sc read - addr off size
spi_nand_sc write - addr off size
    read/write 'size' bytes starting at offset 'off'
               offset ignores 'spare'     to/from memory address 'addr'.
spi_nand_sc erase off size - erase 'size' bytes from offset 'off'
'size' and 'off' are block size alignment
spi_nand
SPI-NAND sub-system
info - show available NAND devices
spi_nand read - addr off size
spi_nand read.raw - addr off size
spi_nand write - addr off size
spi_nand write.raw - addr off size
    read/write 'size' bytes starting at offset 'off'
               offset ignores 'spare'     to/from memory address 'addr'.
    read.raw/write.raw skip ECC
spi_nand erase off size - erase 'size' bytes from offset 'off'
'size' and 'off' are block size alignment
true
do nothing, successfully
false
do nothing, unsuccessfully
test
minimal test like /bin/sh
[args..]
Volume %s not found!
dynamic
static
Error initializing mtdparts!
part
Error, no UBI device/partition selected!
Device %d: %s, partition %s
Partition %s not found!
Partition %s not found on device %s!
mtd=%d
mtd=%d,%s
UBI init error %d
UBI: volume information dump:
UBI: vol_id          %d
UBI: reserved_pebs   %d
UBI: alignment       %d
UBI: data_pad        %d
UBI: vol_type        %d
UBI: name_len        %d
UBI: usable_leb_size %d
UBI: used_ebs        %d
UBI: used_bytes      %lld
UBI: last_eb_bytes   %d
UBI: corrupted       %d
UBI: upd_marker      %d
UBI: name            %s
UBI: the 1st 5 characters of the name: %c%c%c%c%c
create
Incorrect type
No size specified -> Using max size (%u)
No space left in UBI device!
Name too long!
Creating %s volume %s of size %d
remove
Remove UBI volume %s (id %d)
It's read-only mode
Error changing Vol tabel record err=%x
UBI: reserve more %d PEBs
UBI error: %s: cannot remove volume %s, error %d
Please see usage
size > volume size! Aborting!
Cannot start volume update
Couldnt or partially wrote data
UBI warning: %s: volume %d on UBI device %d is corrupted
%d bytes written to volume %s
Read %d bytes from volume %s to %p
updating
damaged volume, update marker is set
No size specified -> Using max size (%lld)
read from corrupted volume %d
NO MEM
read err %x
UBI: MTD device name:            "%s"
UBI: MTD device size:            %llu MiB
UBI: physical eraseblock size:   %d bytes (%d KiB)
UBI: logical eraseblock size:    %d bytes
UBI: number of good PEBs:        %d
UBI: number of bad PEBs:         %d
UBI: smallest flash I/O unit:    %d
UBI: VID header offset:          %d (aligned %d)
UBI: data offset:                %d
UBI: max. allowed volumes:       %d
UBI: wear-leveling threshold:    %d
UBI: number of internal volumes: %d
UBI: number of user volumes:     %d
UBI: available PEBs:             %d
UBI: total number of reserved PEBs: %d
UBI: number of PEBs reserved for bad PEB handling: %d
UBI: max/mean erase counter: %d/%d
verify_mkvol_req failed %d
ubi commands
part [part] [offset]
 - Show or set current partition (with optional VID header offset)
ubi info [l[ayout]] - Display volume and ubi layout information
ubi create[vol] volume [size] [type] - create volume name with size
ubi write[vol] address volume size - Write volume from address with size
ubi read[vol] address volume [size] - Read volume to address with size
ubi remove[vol] volume - Remove volume
[Legends]
 volume: character name
 size: specified in bytes
 type: s[tatic] or d[ynamic] (default=dynamic)
ustar  
File in Tar: %s at 0x%08x (size: 0x%08x)
uImage
fwu_ver
Update SW Version: %s
sw_version0
%s empty, set %s
old %s [%s] is different to new [%s], set new version
sw_version1
Update Image CRC32
sw_crc0
%08lx
old %s [%s] is different to new [%s], set new crc
sw_crc1
img.tar is located at %p (size = 0x%08x)
kernel image is at 0x%08x (size: 0x%08x)
rootfs image is at 0x%08x (size: 0x%08x)
Firmware Version: [%s]
spi_nand erase %x %x; spi_nand write %x %x %x
Error: image size is larger than the partition, operation aborted
CMD = %s
2nd kernel partition at 0x%08x, size=0x%08x
2nd rootfs partition at 0x%08x, size=0x%08x
Update img.tar Done
upimgtar
update kernel and rootfs by tar format on luna platform
ADDRESS
SIZE
Description:
Extract kernel and rootfs in tar file located at ADDRESS and write them into corresponding partitions.
vmimg is located at %p
Kernel image key consistent, start updating...
kernel image size=0x%08x(%u)
spi_nand erase %x %x;spi_nand write %x %x %x
Error: kernel key mismatch, key found in image is 0x%08x, but should be 0x%08x
Operation aborted
CMD=%s
rootfs image key consistent, start updating...
rootfs image size=0x%08x(%u)
Error: rootfs key mismatch, key found in image is 0x%08x, but should be 0x%08x
run erase_env
Update vm.img Done
#1 Key: 0x%08x
#2 Key: 0x%08x
upvmimg
update kernel and rootfs by vmimg format on luna platform
ADDRESS
Description:
Extract kernel and rootfs in vmimg image located at ADDRESS and write them into corresponding partitions.
mips-linux-xgcc (Realtek MSDK-4.8.5p1 Build 2220) 4.8.5 20150209 (prerelease)
GNU ld (Realtek MSDK-4.8.5p1 Build 2220) 2.24.0.20141017
version
print monitor, compiler and linker version
## Copying part %d from legacy image at %08lx ...
Must specify load address for %s command with compressed image
Bad Image Part
Invalid image type for imxtract
   Loading part %d ... 
   Uncompressing part %d ... 
GUNZIP ERROR - image not loaded
%8lx
fileaddr
imxtract
extract a part of a multi-image
addr part [dest]
    - extract <part> from legacy image at <addr> and copy to <dest>
%s - %s
Usage:
- No additional help available.
%-*s- %s
Unknown command '%s' - try 'help' without arguments for list of all known commands
*** Warning - %s, using default environment
Using default environment
env_common.c
!bad CRC
ERROR: Cannot import environment: errno = %d
at %s:%d/%s()
!import failed
env_spi_nand.c
II: erasing spi-nand... 
II: writing to spi-nand... 
!readenv() failed
SPI-NAND
syntax error
ERROR : memory not allocated
 ** Abort
VD2# 
*?[\
ERROR: There is a global environment variable with the same name.
%s: readonly variable
\$'"
;&|#
Unknown command '%s' - try 'help' or use 'run' command
Unknown command '%s' - try 'help'
;$&|
exit not allowed from main input shell.
<INTERRUPT>
HUSH_VERSION
0.01
showvar
print local hushshell variables
    - print values of all hushshell variables
showvar name ...
    - print value of hushshell variable 'name'
then
elif
else
while
until
done
bootm_low
bootm_size
bootm_mapsize
%d Bytes = 
Unknown OS
Unknown Architecture
Unknown Image
Unknown Compression
%sImage Name:   %.*s
%sCreated:      
%4d-%02d-%02d  %2d:%02d:%02d UTC
%sImage Type:   
%s %s %s (%s)
%sData Size:    
%sLoad Address: %08x
%sEntry Point:  %08x
%sContents:
%s   Image %d: 
%s    Offset = 0x%08lx
## Loading init Ramdisk from Legacy Image at %08lx ...
No Linux %s Ramdisk Image
Wrong Ramdisk Image Format
## Loading init Ramdisk from multi component Legacy Image at %08lx ...
uncompressed
bzip2
bzip2 compressed
gzip
gzip compressed
lzma
lzma compressed
lzo compressed
aisimage
Davinci AIS image
filesystem
Filesystem Image
firmware
Firmware
flat_dt
Flat Device Tree
kernel
Kernel Image
kernel_noload
Kernel Image (no loading done)
kwbimage
Kirkwood Boot Image
imximage
Freescale i.MX Boot Image
Invalid Image
multi
Multi-File Image
omapimage
TI OMAP SPL With GP CH
ramdisk
RAMDisk Image
script
Script
standalone
Standalone Program
ublimage
Davinci UBL image
Invalid OS
Linux
netbsd
NetBSD
Enea OSE
rtems
RTEMS
u-boot
U-Boot
Invalid ARCH
alpha
Alpha
Intel x86
ia64
IA64
m68k
M68K
microblaze
MicroBlaze
mips
MIPS
mips64
MIPS 64 Bit
nios2
NIOS II
powerpc
PowerPC
s390
IBM S390
SuperH
sparc
SPARC
sparc64
SPARC 64 Bit
blackfin
Blackfin
avr32
AVR32
nds32
NDS32
%.*s
** Too many args (max. %d) **
## Command too long!
'bootd' recursion detected
bootdelay
Prod Buil, No Chance to get into CLI!
Load Standalone Code from flash to buffer address in DRAM...
sc_led off 20
Load Standalone Code from flash to buffer address in DRAM 2...
serial
Cksum
xyzModem - %s mode, %d(SOH)/%d(STX)/%d(CAN) packets, %d retries
Unknown error
Block sequence error
CRC/checksum error
Invalid framing
Cancelled
End of file
Timed out
Sorry, zModem not available yet
Can't access file
U-Boot BUG at %s:%d!
mtdcore.c
Removing MTD device #%d (%s) with use count %d
Creating %d MTD partitions on "%s":
memory allocation error while creating partitions for "%s"
Moving partition %d: 0x%012llx -> 0x%012llx
0x%012llx-0x%012llx : "%s"
mtd: partition "%s" is out of reach -- disabled
mtd: partition "%s" extends beyond the end of device "%s" -- size truncated to %#llx
BUG: failure at %s:%d/%s()!
mtdpart.c
BUG!
mtd: partition "%s" doesn't start on an erase block boundary -- force read-only
mtd: partition "%s" doesn't end on an erase block -- force read-only
UBI error: %s: refuse attaching mtd%d - it is already emulated on top of UBI
UBI: attaching mtd%d to ubi%d
UBI error: %s: multiple regions, not implemented
UBI error: %s: unaligned VID header shift %d
UBI error: %s: bad VID header (%d) or data offsets (%d)
UBI warning: %s: EC and VID headers are in the same minimal I/O unit, switch to read-only mode
UBI: MTD device %d is write-protected, attach in read-only mode
UBI: sub-page size:              %d
ubi%d
UBI error: %s: cannot clean auto-resize flag for volume %d
UBI error: %s: cannot auto-resize volume %d
UBI: volume %d ("%s") re-sized from %d to %d LEBs
UBI error: %s: cannot add volume %d
UBI error: %s: cannot initialize UBI %s, error %d
UBI error: %s: cannot spawn "%s", error %d
UBI: attached mtd%d to ubi%d
UBI error: %s: min. I/O unit (%d) is not power of 2
UBI error: %s: %s reference count %d, destroy anyway
UBI: mtd%d is detached from ubi%d
UBI error: %s: too many MTD devices, maximum is %d
UBI error: %s: cannot create UBI class
UBI error: %s: cannot attach mtd%d
UBI error: %s: UBI error: cannot initialize UBI, error %d
UBI error: too many parameters, max. is %d
UBI error: parameter "%s" is too long, max. is %d
UBI warning: empty 'mtd=' parameter - ignored
UBI error: too many arguments at "%s"
UBI error: incorrect bytes count: "%s"
UBI error: %s: bad CRC at record %u: %#08x, not %#08x
UBI error: %s: volumes %d and %d have the same name "%s"
UBI error: %s: volume table check failed: record %d, error %d
UBI: create volume table (copy #%d)
UBI error: %s: the layout volume was not found
UBI warning: %s: volume table copy #2 is corrupted
UBI: volume table was restored
UBI error: %s: both volume tables are corrupted
UBI warning: %s: volume table copy #1 is corrupted
UBI error: %s: more then one auto-resize volume (%d and %d)
UBI warning: %s: static volume %d misses %d LEBs - corrupted
layout volume
UBI error: %s: not enough PEBs, required %d, available %d
UBI error: %s: scanning found %d volumes, maximum is %d + %d
UBI error: %s: too large volume ID %d found by scanning
UBI: finish volume %d removal
UBI error: %s: bad scanning information, error %d
%s_%d
UBI error: %s: cannot create volume %d, error %d
UBI error: %s: cannot remove volume %d, error %d
UBI warning: %s: mark volume %d as corrupted
UBI warning: %s: switch to read-only mode
UBI warning: %s: bad VID header at PEB %d, LEB%d:%d
UBI: force data checking
UBI warning: %s: CRC error: calculated %#08x, must be %#08x
UBI warning: %s: failed to write data to PEB %d
UBI: recover PEB %d, move data to PEB %d
UBI: data was successfully recovered
UBI warning: %s: failed to write to PEB %d
UBI: try again
UBI warning: %s: failed to write VID header to LEB %d:%d, PEB %d
UBI warning: %s: failed to write %d bytes at offset %d of LEB %d:%d, PEB %d
UBI: try another PEB
UBI warning: %s: failed to write %d bytes of data to PEB %d
UBI warning: %s: error %d while reading data from PEB %d
UBI warning: %s: cannot read VID header back from PEB %d
UBI warning: %s: cannot read data back from PEB %d
UBI warning: %s: read data back from PEB %d - it is different
UBI error: %s: no enough physical eraseblocks (%d, need %d)
UBI warning: %s: cannot reserve enough PEBs for bad PEB handling, reserved %d, need %d
UBI error: %s: cannot erase PEB %d, error %d
UBI error: %s: cannot erase PEB %d
UBI: fixable bit-flip detected at PEB %d
UBI error: %s: error %d while reading %d bytes from PEB %d:%d, read %zd bytes
%s[%d] not here
UBI error: %s: read-only mode
UBI error: %s: error %d while writing %d bytes to PEB %d:%d, written %zd bytes
UBI error: %s: read problems on freshly erased PEB %d, must be bad
UBI error: %s: erased PEB %d, but a non-0xFF byte found
UBI error: %s: pattern %x checking failed for PEB %d
UBI error: %s: error %d while checking if PEB %d is bad
UBI error: %s: cannot mark PEB %d bad, error %d
UBI warning: %s: no EC header found at PEB %d, only 0xFF bytes
UBI warning: %s: bad magic number at PEB %d: %08x instead of %08x
UBI warning: %s: bad EC header CRC at PEB %d, calculated %#08x, read %#08x
UBI error: %s: node with incompatible UBI version found: this UBI version is %d, image version is %d
UBI error: %s: bad VID header offset %d, expected %d
UBI error: %s: bad data offset %d, expected %d
UBI error: %s: bad erase counter %lld
UBI error: %s: bad EC header
UBI error: %s: validation failed for PEB %d
UBI warning: %s: no VID header found at PEB %d, only 0xFF bytes
UBI warning: %s: bad CRC at PEB %d, calculated %#08x, read %#08x
UBI error: %s: bad VID header
UBI error: %s: work failed with error code %d
UBI error: %s: erase counter overflow at PEB %d, EC %llu
UBI error: %s: failed to erase PEB %d, error %d
UBI error: %s: bad physical eraseblock %d detected
UBI error: %s: no reserved physical eraseblocks
UBI: mark PEB %d as bad
UBI warning: %s: last PEB from the reserved pool was used
UBI error: %s: error %d while reading VID header from PEB %d
UBI error: %s: error %d while moving PEB %d to PEB %d
UBI error: %s: no free eraseblocks
wl.c
UBI error: %s: PEB %d not found
UBI: schedule PEB %d for scrubbing
UBI: background thread "%s" started, PID %d
UBI error: %s: %s: work failed with error code %d
UBI: %s: %d consecutive failures
ubi_bgt%dd
UBI error: %s: inconsistent VID header at PEB %d
scan.c
UBI error: %s: two LEBs with same version %u
UBI error: %s: two LEBs with same sequence number %llu
UBI error: %s: PEB %d and PEB %d have the same version %lld
UBI error: %s: erase counter overflow at PEB %d, EC %d
UBI error: %s: no eraseblocks found
UBI error: %s: this UBI version is %d, image version is %d
UBI error: %s: erase counter overflow, max is %d
UBI: "delete" compatible internal volume %d:%d found, remove it
UBI: read-only compatible internal volume %d:%d found, switch to read-only mode
UBI: "preserve" compatible internal volume %d:%d found
UBI error: %s: incompatible internal volume %d:%d found
UBI: empty MTD device detected
%llu Bytes%s
.%ld
 %cB%s
 %0*x
    %s
1.2.3
Error: inflateInit2() returned %d
Error: inflate() returned %d
Error: Bad gzipped data
Error: gunzip out of data in header
Env export buffer too small: %zu, but need %zu
himport_r: can't insert "%s=%s" into hash table
dcache on
.%03ld
Extraction failed!
<NULL>
(null)
%s:%u: %s: Assertion `%s' failed.
invalid distance too far back
invalid distance code
invalid literal/length code
incorrect header check
unknown compression method
invalid window size
unknown header flags set
header crc mismatch
invalid block type
invalid stored block lengths
too many length or distance symbols
invalid code lengths set
invalid bit length repeat
invalid literal/lengths set
invalid distances set
incorrect data check
incorrect length check
need dictionary
stream end
file error
stream error
data error
insufficient memory
buffer error
incompatible version
*** WARNING: %s is too long (%d - max: %d) - truncated
Host Name
Root Path
NIS Domain Name
BOOTP broadcast %d
Retry count exceeded; starting again
ethact
%s%daddr
%saddr
eth.c
Sync Env Mac!
eth%dmacskip
ethmacskip
Board Net Initialization Failed
CPU Net Initialization Failed
Net Initialization Skipped
No ethernet found.
ethprime
 [PRIME]
Warning: eth device name has a space!
Warning: failed to set MAC address
ethrotate
unknown
autoload
netretry
once
## Warning: gatewayip needed but not set
ARP Retry count exceeded; starting again
bad length %d < %d
len bad %d < %d
checksum bad
 ICMP Host Redirect to %pI4 
%d.%d.%d.%d
nvlan
vlan
*** ERROR: `serverip' not set
*** ERROR: `ipaddr' not set
*** ERROR: No ethernet found.
*** ERROR: `ethaddr' not set
*** ERROR: `eth%daddr' not set
Abort
Bytes transferred = %ld (%lx hex)
octet
blksize%c%d%c
File too large
File has bad magic
blksize
TFTP error: First block is not block 1 (%ld)
Starting again
done
TFTP error: '%s' (%d)
Not retrying...
Starting again
%s; starting again
Retry count exceeded
tftpblocksize
tftptimeout
TFTP timeout (%ld ms) too low, set minimum = 1000 ms
%02X%02X%02X%02X.img
*** Warning: no boot file name; using '%s'
Using %s device
TFTP %s server %pI4; our IP address is %pI4
from
; sending through gateway %pI4
Filename '%s'.
 Size is 0x%x Bytes = 
Load address: 0x%lx
Loading: *
**********************************************************
%-25s:	0x%x
Memory Base
UBoot Text Start
UBoot Text End
UBoot RODATA Start
UBoot RODATA End
UBoot DATA Start
UBoot DATA End
UBoot _gp
UBoot SDATA End
UBoot SW Patch Start
UBoot SW Patch End
UBoot End of Data
UBoot End
Standalone Text
Standalone Buf
SCFLMAPOK
SC_DEBUG: Nand Partition Table Magic Found at %x.
gpio_init
sc_sec_upg
fl_map
get_mac
boot_toggle_led
CleanBSS
boot_init_lte
Do not know what to do ... 
%x %x %x %x %x %x 
sc_mem_usage_info
SC: SC memory usage
sc_boot_flg
SC: SC switch boot flag command, every switch would make flag+1
sc_btver
SC: SC Show Bootloader Version(SC), and dump compile timestamp
sc_fl_map
SC: SC Defined Flash Map Dump
sc_cpureg
SC: sc debug for read/write cpu registers
usage:
	sc_cpureg <r|w> <address> [data]
sc_gpio
SC: sc debug command for gpio operations
usage:
	sc_gpio d : display gpio register values
	sc_gpio i <gpio_num_in_decimal> : set certain gpio as input
	sc_gpio o <gpio_num_in_decimal> : set certain gpio as output
	sc_gpio w <gpio_num_in_decimal> <1|0> : set gpio high or low
	sc_gpio r <gpio_num_in_decimal> : get gpio input
sc_led
SC: sc debug command for led & buttons
usage:
	sc_led on all : set all leds on
	sc_led off all : set all leds off
	sc_led on <led_num_in_decimal> : set certain led on
	sc_led off <led_num_in_decimal> : set certain led off
	sc_led info : dump led & button maps w/ GPIO
sc_nand
SC: sc nand flash
usage:
	sc_nand r <offset>  : dump page data and oob by given offset(in hex)
	sc_nand w <offset> <data>  : write one byte data to flash
	sc_nand e <offset>  : erase block(f option of BDS is not supported)
	sc_nand markbad <offset> : mark one block as bad block 
	sc_nand clearbad <offset>: clear bad block tag 
	sc_nand b [offset] : scan bad block
	sc_nand oob : dump oob of first page for whole flash
sc_lp
SC: loopback
sc_lp 
SC: sercomm upgrade
sc_sec_upg [debug_level], debug_level = <0..3>, 0 - all, 1 - warn, 2 - info, 3- error, defaule is 2
sc_time
SC: sercomm timer test command 
sc_time <time>, time is in decimal
Board: VD2, CPU:%dMHz, LX:%dMHz, DDR%d:%dMHz
reset_all
Perform whole chip RESET of the CPU
mdram_test
mdram_test   - do DRAM test.
[-l/-loops <test loops>] [-r/-range <star address> <test size>] [-b/-block_e] [-reset <all>] [-pstr <pass msg>] [-fstr <fail msg>]
    - do DRAM test.
btg 
II: BTG-LX%d(%s) is NOT available
II: BTG-LX%d(%s) @ %08x Configuration:
II:   rec_latest: %d	precise: %d
II:   rchkmode:  %d	burstlen: %d B
II:   pktlen: %d B	iter: %d
II:   resp_time: %d C	perid_time: %d C
II:   addr_base: %08x	addr_mask: %08x
II:   addr_gap: %08x
II:   covered range: %08x ~ %08x
II: Status:
II:   Int. Status Reg.: %08x
II:   In progress? %c
II:   Int. %d, Addr. fails response time: %08x
II:   Int. %d, Addr. fails period:        %08x
II:   Int. %d, Addr. fails verification:  %08x
II:   Max response time: %d(0x%08x) cycles
II: BTG-LX%d(%s) @ %08x:
II:   %p: %08x %08x %08x %08x
II: BTG-LX%d(%s) 
is NOT avaiable
@ %08x: %08x ~ %08x... 
stopped
enabled
WW: packet length is capped to 8160B
EE: BTG-LX%d is not available
rec_latest
precise
rchkmode
burstlen
pktlen
iter
resp_time
perid_time
addr_base
addr_mask
addr_gap
EE: unknown parameter
stop
II: Resetting 
BTG-LX%d... 
N/A; 
done; 
EE: unknown BTG function
EE: unknown BTG
bus traffic generator sub-system
II: do spi-nand pio test... write... 
BLK%04d
EE: pattern check failed!
verify... 
EE: PAGE%04d,COL%04d,data:0x%08x != pattern:0x%08x
done       
II: do spi-nand dma test ... write... 
EE: pattern write to addr(0x%x) 0x%x!=0x%x
EE: double confirm, BLK%04d,PAGE%04d,COL%04d, dst(addr:0x%x)0x%x != src(addr:0x%x)0x%x
II: do dma/pio raw cross test... 
dma w...
(BBI:%d) 
EE: pattern write to addr(0x%x) 0x%x!=0x%x
pio r...
EE: dw-pr, PAGE%04d,COL%04d, data:0x%08x != pattern:0x%08x
pio w...
dma r...
EE: pw-dr, PAGE%04d,COL%04d, dst(addr:0x%x)0x%x != pat(addr:0x%x)0x%x
...done       
II: do %s ... 
EE: dw-pr, BLK%04d,PAGE%04d: ecc_decode fail (0x%x)
EE: dw-pr, PAGE%04d,COL%04d,data(0x%08x):0x%08x != pattern(0x%08x):0x%08x
EE: pw-dr, BLK%04d,PAGE%04d: ecc_decode fail (0x%x)
EE: pw-dr, PAGE%04d,COL%04d ,dst(0x%x):0x%x != pat(0x%x):0x%x
II: do ecc normal test... write... 
 verify... 
EE: BLK%04d, PAGE%04d, read data 0x%x!=0x%x, ecc(0x%x)
II: do ecc trick test... 
EE: ecc correct error (0x%x)
II: do bad block search: 
BLK%04d 
...done
-loops
WW: invalid loop count(reset to 1)
-range
DD: input range %d %d
-reset
-reset_all
-bad
-all_case
WW: unknown command "%s" ignored.
EE: input error
EE: incomplete commands (type: %d)
EE: spi-nand flash test failed
EE: snaf_scan_block_wr_with_ecc_test failed
II: spi_nand test info:
	start: BLK%04d, end: BLK%04d
	loop: %d, reset type: %s
	bad block search only: %c
	all_testcase: %c
	Only block scan(w/ ecc): %c
II: #%d test
msnaf_test
msnaf_test  - do spi-nand flash test. 
-r/-range <start block> <block count> [-l/-loops <test loops>] [-ac/-all_case] [-reset/-reset_all] [-bad]
    => do spi-nand flash test.
    => [-ac/-all_case]: Set '1' to do all test cases, or only do 'Block Scan Pattern' case.
=======start %s test=======
addr(0x%x): 0x%x != pattern(0x%x) %s, %d
%s (%d) test failed.
pattern[%d](0x%x) 0x%x pass
%s test completed.                   
pattern[%d](0x%x) 0x%x passed
decr addr(0x%x): 0x%x != pattern(0x%x) %s, %d i=%d j=0x%x
seq addr(0x%x): 0x%x != pattern(0x%x) %s, %d
rotate %d 0x%x passed
decr addr(0x%x): 0x%x != pattern(0x%x) %s, %d
~rotate %d 0x%x passed
addr:0x%x(0x%x) != pattern(0x%x) %s, %d
memcpy %d 0x%x passed
offset 1 error:addr(0x%x) write 0x%x, read 0x%x, c1(%02x)
offset 2 error:addr(0x%x) write 0x%x, read 0x%x, c1(0x%x), c2(0x%x)
&dram_pattern[%d](0x%p) = 0x%x
offset 3 error:addr(0x%x) write 0x%x, read 0x%x, c1(%02x), c2(%02x), c3(%02x)
%s test passed.                   
ADDRESS WORDSET addr_base: 0x%08x times: %d, pattern: Address
pdata(0x%08x) 0x%08x != 0x%08x, %s, %d
RANDOM 
FIXED  
BYTESET 
WORDSET 
addr_base: 0x%08x times: %d, pattern: 0x%08x
RANDOM 
FIXED  
BYTESET 
WORDSET 
cache_flush_dispersed(0,0) error
cache_flush_dispersed(0,1) error
cache_flush_dispersed(1,0) error
cache_flush_dispersed(1,1) error
cache_flush_adjacent(0,0) error
cache_flush_adjacent(0,1) error
cache_flush_adjacent(1,0) error
cache_flush_adjacent(1,1) error
cache_flush_adj_addr error
cache_flush_adjacent_toggle_word error
cache_flush_dispersed_toggle_word error
cache_flush_adjacent_toggle_line128 error
%s test completed.                                  
mt_block_e
ERR: Illegal command (%d).
WW: loop count capped.
ERR: Please assign the memory test range: -r <start address> <size>.
ERR: Incorrect memory test rnage.
ERR: The assigned test range is for stack and u-boot use.
-block_e
-pstr
-fstr
<Only one test area!>
II: # of iteration: %d
<Range %d: 0x%x~0x%x>
Uncached with no prefetch, DRAM Test start = 0x%x
Cached with no prefetch, DRAM Test start = 0x%x
Cached with data prefetch, DRAM Test start = 0x%x
Cached with ins. prefetch, DRAM Test start = 0x%x
Cached with data/ins. prefetch, DRAM Test start = 0x%x
<mdram_test %d runs>                  
        
ZZZZ
U-Boot 2011.12.200M-svn199 (Apr 02 2021 - 15:47:01)
all [reset|start|stop|info|reg]
btg all set [garg] [val]
btg [lx0|lx1|lx2] [w|r] [start|stop|info|reg]
btg [lx0|lx1|lx2] [w|r] set [iarg] [val]
  supported iarg:
    rec_latest: 0 for record the first error; 1 for the latest one
       precise: 0 for imprecise; 1 for precise
      rchkmode: 0 for do no check; 1 for using DG; 2 for checksum
      burstlen: 0 for 16, 1 for 32, 2 for 64, and 3 for 128 bytes
        pktlen: 1 ~ 8160 bytes
          iter: 0 for infinite; others for 1 ~ 4G times
     resp_time: 0 ~ 4G cycles
    perid_time: 0 ~ 4G cycles
     addr_base: physical address BTG starts from
     addr_mask: combine with addr_base to form a region
      addr_gap: distance for next WR/RD
  suggested flow:
    btg all reset => btg ... set ... => btg ... start
W$hZZZZ$h5y
